#!python3
# -*- coding: utf-8 -*-

from pathlib import Path
from pprint import pprint


import argparse
import csv
import sys
import xml.etree.ElementTree as ET


KOFTA_ARGV_SIZE = 128
KOFTA_VERSION = "0.10"

CBLK = "\x1b[0;30m"
CRED = "\x1b[0;31m"
CGRN = "\x1b[0;32m"
CBRN = "\x1b[0;33m"
CBLU = "\x1b[0;34m"
CMGN = "\x1b[0;35m"
CCYA = "\x1b[0;36m"
CLGR = "\x1b[0;37m"
CGRA = "\x1b[1;90m"
CLRD = "\x1b[1;91m"
CLGN = "\x1b[1;92m"
CYEL = "\x1b[1;93m"
CLBL = "\x1b[1;94m"
CPIN = "\x1b[1;95m"
CLCY = "\x1b[1;96m"
CBRI = "\x1b[1;97m"
CRST = "\x1b[0m"


quiet: int = False


def psay(msg: str, /, *args, **kwargs) -> None:
    print(msg, file=sys.stderr, *args, **kwargs)


def pwarn(msg: str, /, *args, **kwargs) -> None:
    if quiet < 2:
        psay(f"{CYEL}[!] {CBRI}WARNING: {CRST}{msg}", *args, **kwargs)


def pact(msg: str, /, *args, **kwargs) -> None:
    if quiet < 3:
        psay(f"{CGRN}[*] {CRST}{msg}", *args, **kwargs)


def pok(msg: str, /, *args, **kwargs) -> None:
    if quiet < 3:
        psay(f"{CGRN}[+] {CRST}{msg}", *args, **kwargs)


def pfatal(msg: str, /, *args, **kwargs) -> None:
    if quiet < 4:
        psay(f"{CRED}[-] {CBRI}PROGRAM ABORT: {CRST}{msg}", *args, **kwargs)
    sys.exit(1)


def get_files(dir: Path) -> list[Path]:
    """
    Get all files in a directory with a specific extension.
    """

    files = []
    for file in dir.iterdir():
        if file.is_file():
            files.append(file)
    return files


def get_arglist(state_dir: Path, prune: bool) -> list[Path]:

    arglist = get_files(state_dir / "arglist" / "queue")
    arglist += get_files(state_dir / "arglist" / "crashes")

    if prune:
        redundants = [r.name for r in get_files(state_dir/ "queue" / ".state" / "redundant_edges")]
        arglist = [l for l in arglist if l.name not in redundants]

    return arglist


def parse_opts(arglist: list[Path]) -> dict[str, dict[str, int]]:

    options: dict[str, dict[str, int]] = {}

    for i, l in enumerate(arglist):
        pact(f"Processing {i + 1} / {len(arglist)} ...", end="\r")
        with l.open("rb") as f:
            na = int.from_bytes(f.read(1), byteorder="little")
            _  = int.from_bytes(f.read(1), byteorder="little")
            no = int.from_bytes(f.read(1), byteorder="little")
            f.seek(na * KOFTA_ARGV_SIZE, 1)
            opt = ""
            while no:
                no -= 1
                s = f.read(KOFTA_ARGV_SIZE)
                s = s[:s.find(b"\x00")]
                if s.startswith(b"-"):
                    opt = s.decode("utf-8")
                    if opt not in options:
                        options[opt] = {}
                else:
                    try:
                        s = s.decode("utf-8")
                    except:
                        pwarn(f"Warning: could not decode option {opt} value in {l} !")
                        continue
                    if s == "":
                        pwarn(f"Warning: empty option {opt} value in {l} !")
                        continue
                    if s not in options[opt]:
                        options[opt][s] = 0
                    options[opt][s] += 1
    psay("")
    pok("Processing done!\n")

    return options


def save_csv(options: dict[str, dict[str, int]], output_dir: Path):

    output_dir.mkdir(parents=True, exist_ok=True)

    with (output_dir / "opts.csv").open("w") as f:
        writer = csv.writer(f)
        writer.writerow(["option", "value", "count"])
        for opt, values in options.items():
            for value, count in values.items():
                writer.writerow([opt, value, count])
            if not values.items():
                writer.writerow([opt, "", ""])

    pok(f"CSV output saved to {output_dir / 'opts.csv'}")


def save_xml(options: dict[str, dict[str, int]], output_dir: Path):

    output_dir.mkdir(parents=True, exist_ok=True)

    root = ET.Element("root")
    ET.SubElement(ET.SubElement(root, "FILE"), "ELEMENT").text = "@@"

    for opt, values in options.items():
        param = ET.SubElement(root, "PARAMETER")
        ET.SubElement(param, "MUST").text = "false"
        if not values:
            ET.SubElement(param, "ELEMENT").text = opt
        for value in values:
            ET.SubElement(param, "ELEMENT").text = f"{opt} {value}"

    ET.indent(root)
    ET.ElementTree(root).write(output_dir / "parameters.xml", encoding="utf-8")

    pok(f"XML output saved to {output_dir / 'parameters.xml'}")


def parse_args() -> argparse.Namespace:

    parser = argparse.ArgumentParser(description="Counts the number of options generated by kofta-fuzz.")

    parser.add_argument("outdir",         metavar="OUTPUT_DIR",  type=Path, nargs="?",                          help="output directory to save the results")

    parser.add_argument("-d", "--dir",    metavar="STATE_DIR",   type=Path, dest="dirs",   action="append",     help="a directory containing AFL state data")
    parser.add_argument("-g", "--group",  metavar="STATE_GROUP", type=Path, dest="groups", action="append",     help="a group containing multiple AFL states")

    parser.add_argument("-c", "--csv",                                                     action="store_true", help="output in CSV format")
    parser.add_argument("-x", "--xml",                                                     action="store_true", help="output in XML format (Wei-fuzz's parameters.xml)")

    parser.add_argument("-p", "--prune",                                                   action="store_true", help="prune redundant options (default: False)")
    parser.add_argument("-q", "--quiet",                                                   action="count",      help="don't print results to stdout", default=0)

    return parser.parse_args()


def main():
    global quiet

    print(f"{CCYA}kofta-opts {CBRI}{KOFTA_VERSION}{CRST} by <me@alardutp.dev>\n")

    args = parse_args()

    groups: list[Path] = args.groups if args.groups else []
    dirs: list[Path] = args.dirs if args.dirs else []

    csv_output: bool = args.csv
    xml_output: bool = args.xml

    prune: bool = args.prune
    quiet = args.quiet

    outdir: Path = args.outdir if args.outdir else Path.cwd()

    arglist: list[Path] = []

    for group in groups:
        for dir in group.iterdir():
            if not dir.is_dir():
                continue
            dirs.append(dir)

    for dir in dirs:
        arglist += get_arglist(dir, prune)

    options = parse_opts(arglist)

    if not options:
        pfatal("No options found!")

    if not quiet:
        pprint(options)

    if csv_output:
        save_csv(options, outdir)

    if xml_output:
        save_xml(options, outdir)


if __name__ == "__main__":
    main()
