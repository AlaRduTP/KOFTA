#!python3
# -*- coding: utf-8 -*-

from pathlib import Path

import argparse
import csv
import subprocess


import debug

from debug import psay, pact, pok, pwarn, pfatal, phello


KOFTA_ARGV_SIZE = 128


def trigger_crash(args: list[bytes], crash: Path) -> None | tuple[str, list[bytes]]:
    arglist = crash.parent.parent / "arglist" / "crashes" / crash.name
    if not arglist.exists():
        pwarn(f"Skipping {crash.name}, no arglist found.")
        return None

    cur_input: Path = Path.cwd() / ".cur_input"
    cur_input.write_bytes(crash.read_bytes())

    opts: list[bytes] = []
    with arglist.open("rb") as f:
        na = int.from_bytes(f.read(1), byteorder="little")
        np = int.from_bytes(f.read(1), byteorder="little")
        no = int.from_bytes(f.read(1), byteorder="little")
        f.seek(KOFTA_ARGV_SIZE * na, 1)
        while no:
            no -= 1
            s = f.read(KOFTA_ARGV_SIZE)
            s = s[:s.find(b"\x00")]
            opts.append(s)
    cmd = args[:np] + opts + args[np:]

    result = subprocess.run(cmd, capture_output=True)
    stderr = result.stderr.decode()

    report = stderr.split("SUMMARY: AddressSanitizer: ")
    if len(report) < 2:
        pwarn(f"No crash reported for {crash.name}.")
        return None

    summary = report[1].split("\n")[0]
    psay(summary)
    return summary, opts


def get_files(dir: Path) -> list[Path]:
    """
    Get all files in a directory with a specific extension.
    """

    files = []
    for file in dir.iterdir():
        if file.is_file():
            files.append(file)
    return files


def parse_args() -> argparse.Namespace:

    parser = argparse.ArgumentParser(description="Counts the number of options generated by kofta-fuzz.")

    parser.add_argument("asan",           metavar="ASAN_PROG",   nargs="+",                                     help="target program compiled with ASAN")

    parser.add_argument("-d", "--dir",    metavar="STATE_DIR",   type=Path, dest="dirs",   action="append",     help="a directory containing AFL state data")
    parser.add_argument("-g", "--group",  metavar="STATE_GROUP", type=Path, dest="groups", action="append",     help="a group containing multiple AFL states")

    parser.add_argument("-c", "--csv",                                                     action="store_true", help="output in CSV format")
    parser.add_argument("-q", "--quiet",                                                   action="count",      help="don't print results to stdout", default=0)

    return parser.parse_args()


def main():

    phello("kofta-opts")

    args = parse_args()

    groups: list[Path] = args.groups if args.groups else []
    dirs: list[Path] = args.dirs if args.dirs else []

    csv_output: bool = args.csv
    debug.quiet = args.quiet

    asan: list[str] = args.asan
    outdir: Path = Path.cwd()

    crashes: list[Path] = []

    for group in groups:
        for dir in group.iterdir():
            if not dir.is_dir():
                continue
            dirs.append(dir)

    for dir in dirs:
        crashes += get_files(dir / "crashes")

    if not crashes:
        pfatal("No crashes found!")

    pok(f"Found {len(crashes)} crashes in {len(dirs)} directories.")

    args: list[bytes] = []
    for p in asan:
        if p == '@@':
            args.append('.cur_input'.encode())
        else:
            args.append(p.encode())

    report: dict[str, dict[str, list[bytes]]] = {}

    for i, crash in enumerate(crashes):
        pact(f"Processing crash {i + 1}/{len(crashes)}")
        result = trigger_crash(args, crash)
        if result:
            summary, opts = result
            if summary not in report:
                report[summary] = {}
            report[summary][str(crash)] = opts

    pact(f"Generating crash report ...")
    for summary, crash in report.items():
        try:
            reason, cause = summary.split(" ", 1)
        except:
            reason = summary
            cause = "Unknown cause"
        psay(f"\n{reason}\n -> {cause}")
        for poc, opts in crash.items():
            psay(f"\n -> {poc}\n     -> {opts}")

if __name__ == "__main__":
    main()
